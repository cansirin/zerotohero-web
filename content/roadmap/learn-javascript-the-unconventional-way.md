+++
#   (`-')           (`-').->
#   ( OO).->        (OO )__
# ,(_/----. .----. ,--. ,'-' doubt everything,
# |__,    |\_,-.  ||  | |  |
#  (_/   /    .' .'|  `-'  | be curious,
#  .'  .'_  .'  /_ |  .-.  |
# |       ||      ||  | |  | learn.
# `-------'`------'`--' `--'

title = "Learn Your JavaScript the Unconventional Way"
date = "2021-11-27"

[taxonomies]
tags = ["roadmap", "javascript"]
+++

{{img(
  src="/images/size/w1200/2024/03/comfortable.png",
  alt="Leave your comfort zone."
)}}

## Getting Your Feet Wet

Suppose you want a quick overview of **JavaScript** before diving into the real
deal. In that case, [**JavaScript Garden**](https://bonsaiden.github.io/JavaScript-Garden/) 
is an oldie but goldie.

Here are some other resources that you'll find helpful too:

* [**JavaScript Allonge**](https://leanpub.com/javascript-allonge/read)
* [**Eloquent JavaScript**](http://eloquentjavascript.net/)
* [Designing Usable **JavaScript** APIs](https://www.smashingmagazine.com/2012/10/designing-javascript-apis-usability/)
* [Mostly Adequate Guide to **Functional** Programming in **JavaScript**](https://github.com/MostlyAdequate/mostly-adequate-guide)

Once you read the ones above, the following books can supplement your knowledge:

* [The "**_Exploring JS_**" Series](http://exploringjs.com/)
* [JavaScript: The Definitive Guide](https://www.goodreads.com/book/show/148050.JavaScript)
* [Programming JavaScript Applications](https://www.goodreads.com/book/show/15812614-programming-javascript-applications)

Along with these, here are a few additional resources for those who are just
getting started with **JavaScript**:

* [MDN: **Javascript**](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
* [HTMLDog **JavaScript** Tutorials](https://htmldog.com/guides/javascript/)
* [javascript.info](https://javascript.info/)
* [**JavaScript** Kit](http://www.javascriptkit.com/javatutors/index.shtml)
* [ES6 Features](https://github.com/lukehoban/es6features)
* [A Dive Into Plain JavaScript](https://blog.adtile.me/2014/01/16/a-dive-into-plain-javascript/)
* [Common **JavaScript** Gotchas](http://www.jblotus.com/2013/01/13/common-javascript-gotchas/)
* [WikiBooks: **JavaScript**: Introduction](https://en.wikibooks.org/wiki/JavaScript/Introduction)

## Digging Into the Mildly-Confusing

Here are a couple of "_relatively_" confusing parts of **JavaScript** that you  
might want to pay extra attention to:

* [Constructors Considered Mildly Confusing](https://zeekat.nl/articles/constructors-considered-mildly-confusing.html)
* [Prototypes and Inheritance in **JavaScript**](https://msdn.microsoft.com/en-us/magazine/ff852808.aspx)
* [Understanding Prototypes in **JavaScript**](https://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/)
* [Understanding Loose Typing in **JavaScript**](http://blog.jeremymartin.name/2008/03/understanding-loose-typing-in.html)
* [A Deeper Look at **Objects** in **JavaScript**](https://www.kirupa.com/html5/a_deeper_look_at_objects_in_javascript.htm)
* [Understanding **JavaScript** Function Invocation and `this`](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)
* [JavaScript **Module** Pattern In-Depth (_historical_)](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html)
* [**JavaScript**: The Good Parts (_historical_)](https://www.goodreads.com/book/show/2998152.JavaScript_The_Good_Parts)
* [JavaScript **Promises**: an Introduction](https://web.dev/promises/)
* [JavaScript **Scoping** and **Hoisting**](http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html)
* [Understanding JavaScript `bind()`](https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/)
* [**Promise** A+ Specification (_historical_)](https://promisesaplus.com/)
* [**Promise** (_MDN_)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
* [How Do **Promises** Work](https://robotlolita.me/2015/11/15/how-do-promises-work.html)
* [**Callbacks**, Listeners, and **Promises**](http://sporto.github.io/blog/2012/12/09/callbacks-listeners-promises/)
* [Learn **async/await** By Example](https://codeburst.io/javascript-es-2017-learn-async-await-by-example-48acc58bad65)
* [**Generators** and **Channels** in JavaScript](https://medium.com/javascript-inside/generators-and-channels-in-javascript-594f2cf9c16e)
* [**Communicating Sequential Processess** (CSP) in **JavaScript**](http://2ality.com/2017/03/csp-vs-async-generators.html)
* [A Quick Introduction to **CSP** in JavaScript](http://lucasmreis.github.io/blog/quick-introduction-to-csp-in-javascript/)

> **Historical**? 
> 
> The resources marked as "_historical"_ might have outdated examples and
> recommendations, so read them with a grain of salt. Though they still are worth
> reading, don't skip them.

## Patterns and Practices

The more you practice, the more you establish your personal style. There are
also well-known and adopted JavaScript patterns and practices that are tailored
for specific use cases. The following resources can help you in those areas.
When you learn these best practices, you can adapt them to match your style and
make them yours:

* [Learning JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)
* [High-Performance JavaScript](https://www.goodreads.com/book/show/7008656-high-performance-javascript)
* [How to Design Better **JavaScript** **API**s](https://www.smashingmagazine.com/2012/10/designing-javascript-apis-usability)
* [Understanding Object-Oriented JavaScript (_historical_)](https://robotlolita.me/articles/2011/understanding-javascript-oop/)

## Functions and Functional JavaScript

Functional programming is not strictly related to JavaScript; however,
JavaScript is a better fit to be used along with Functional Programming
paradigms.

> **Learn Asynchronous JavaScript Well First**  
> Before diving deeper into **functional** **programming** with JavaScript, you
> might want to get more comfortable with asynchronous flow control concepts,
> including [**`async/await`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
> and [**`Promise`s**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).

Along with those, diving further into [**Functional Programming**](https://en.wikipedia.org/wiki/Functional_programming) 
will change the way you look at the world---in a good way.

The current **JavaScript** programming scene is leaning more and more
towards [[functional programming](https://en.wikipedia.org/wiki/Functional_programming),
so don't be surprised if some of the functional paradigms that you see in the
libraries get merged into the language standards soon.

> **How Do New Features Get Introduced Into JavaScript**
>
> When it comes to adopting new features into the language standards, that is
> how it has been so far: If something gains enough popularity, it finds itself
> in the next version of the language.
>
> For example, first [Bluebird](http://bluebirdjs.com/docs/getting-started.html)
> and other libraries came up with a [**Promise**](https://promisesaplus.com/)
> implementation, and after its widespread
> adoption, [the native `Promise` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
> got itself merged into the language.

Here are some resources to get you started you with **Functional JavaScript**:

* [First-class Function](https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function)
* [**Closures**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
* [Immediately-Invoked Function Expression (_historical_)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)
* [**Currying**](https://javascript.info/currying-partials)
* [**Partial Application** in **JavaScript**](http://benalman.com/news/2012/09/partial-application-in-javascript/)
* [Why **Ramda**?](https://ramdajs.com/)
* [A Beginner's Guide to **Ramda**](https://itnext.io/a-beginners-guide-to-ramda-part-1-7e4a34972e97)
* [Functional Programming Patterns With **Ramda**](https://www.educative.io/courses/functional-programming-patterns-with-ramdajs)

While at there, you might want to experiment with some of the functional
libraries out there to get a taste of how functional programming with JavaScript
feels like. [**Ramda**](https://ramdajs.com/) and 
[**RxJS**](https://github.com/ReactiveX/rxjs) are my favorites:

* [Ramda](https://ramdajs.com/)
* [RxJS](https://github.com/ReactiveX/rxjs)
* [FolkTale](https://folktale.origamitower.com/)
* [LoDash](https://lodash.com/)
* [barely-functional](https://github.com/cullophid/barely-functional)
* [fnuc](https://github.com/algesten/fnuc)
* [fp-dom](https://github.com/fp-dom/)
* [futil](https://github.com/smartprocure/futil-js)
* [js-coroutines](https://github.com/miketalbot/js-coroutines)
* [omg-curry](https://github.com/Debdut/omg-curry)
* [cycle.js](https://cycle.js.org/)

## DOM and Virtual DOM

Strictly speaking Virtual-DOM is not specific to **JavaScript**. And, in fact,
from a 50K feeet overview, it is merely an implementation of
the [double buffering technique](https://en.wikipedia.org/wiki/Multiple_buffering)
that has been around since the dawn of time.

That being said, it's so widespread that it will be helpful for you to learn
virtual dom along with dom. Here are some resources to get you started:

* [Introduction to DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)
* [What is Virtual DOM](https://jbi.sh/what-is-virtual-dom/)
* [Virtual DOM and React Internals](https://reactjs.org/docs/faq-internals.html)

## Learn Your Timers

Related to **flow control**, one concept that's important and most do not pay  
enough attention is how the **event loop**, the **main thread**, the  
**compositor thread**, and various **task queues** and **timers** in  
**JavaScript** runtimes work.

Here's, again, a list of study material to shed some light on it:

* [**Tasks**, **Microtasks**, Queues, and Schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
* [What the Heck is **Event Loop** Anyway](https://www.youtube.com/watch?v=8aGhZQkoFbQ)
* [In the **Loop**](https://www.youtube.com/watch?v=cCOL7MC4Pl0&vl=en)
* [The **Node.js** Event Loops, **Timers**, and `process.nextTick`](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)
* [Timers, **Immediates**, and `process.nextTick`](https://jsblog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3)
* [`setImmediate`](https://github.com/YuzuJS/setImmediate/blob/master/README.md)
* [JavaScript VM internals, **EventLoop**, **Async** and **ScopeChain**s](https://www.youtube.com/watch?v=QyUFheng6J0)
* [What the Heck Is the **Event Loop** Anyway?](https://www.youtube.com/watch?v=8aGhZQkoFbQ)
* [How Node **Event Loop** Really Works](https://www.zcfy.cc/original/how-node-event-loop-really-works-or-why-most-of-the-event-loop-diagrams-are-wrong-2544.html)
* [Leaner Meaner Faster **Animations** with **requestAnimationFrame**](https://www.html5rocks.com/en/tutorials/speed/animations/)
* [Introduction to **Easing** in **JavaScript**](https://www.kirupa.com/html5/introduction_to_easing_in_javascript.htm)

## Learn Various Methods of Communicating With the Server

If you are writing a web application, you'll probably find yourself consuming
external resources and data streams. You'll need to know various ways to
communicate with the remote endpoints. Here are a few articles and references
that can help you with that:

* [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
* [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
* [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
* [Web Messaging](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)
* [Web Sockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
* [Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
* [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
* [What is a Webhook?](https://sendgrid.com/blog/whats-webhook/)
* [Beacon API](https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API)
* [JSONP (_historical_)](https://en.wikipedia.org/wiki/JSONP)
* [Cross-Origin Communication with a Klein Bottle (_historical_)](https://msdn.microsoft.com/en-us/library/bb735305.aspx)

> **Historical**?  
> 
> In this section, the techniques marked "*historical*" in this section
> are---indeed--- **historical**. **Never** resort to them unless there is no 
> other option because you are dealing with some legacy system.

## Know Your Local Stores

Sooner or later, you are going to need to persist your data somewhere on the
client too. There are several options that you can try, each with its pros and
cons. Learn them, and understand which API, tool or technique is the best fit
for what types of scenarios.

Here is a non-exhaustive list of client-side storage technologies:

* [Cookies](https://msdn.microsoft.com/en-us/library/bb735305.aspx)
* [sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
* [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
* [indexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
* [Progressive Web Apps](https://developers.google.com/web/progressive-web-apps/)
* [Offline Storage for Progressive Web Apps](https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa)

There are also storage API wrappers that can make your life easier.  
Here are a few of my selections---[**PouchDB**](https://pouchdb.com/) is my
favorite, by the way:

* [PouchDB](https://pouchdb.com/)
* [Dexie](http://dexie.org/)
* [ZangoDB](https://github.com/erikolson186/zangodb)
* [localForage](https://localforage.github.io/localForage/)
* [JSStore](http://jsstore.net/)

## Learn a JavaScript Type System

If it were a couple of years ago, I'd have said "_you can live without  
using a type system_"; however, the world is leaning towards a strongly-typed  
**JavaScript** ecosystem, and it's leaning towards that direction real fast. So,
better learn your types sooner than later.

Currently, **TypeScript** is the only mature type system that is widely adopted
and worth learning.

* [TypeScript](https://www.typescriptlang.org/)
* [FlowType](https://flow.org/) (*historical*)

## Meta Programming

You'll rarely find yourself in need to
use [reflection or meta programming](https://en.wikipedia.org/wiki/Reflective_programming)
in **JavaScript**. Even when you feel the urge to use reflection, think of a
cleaner way to code that does not involve reflection.
Remember: [clear is better than clever](https://dave.cheney.net/2019/07/09/clear-is-better-than-clever),
and **reflection is never clear**.

* [JavaScript Reflection API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)
* [JavaScript Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
* [`Function.prototype.bind` (*MDN*)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
* [`Function.prototype.apply` (*MDN*)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/apply)

## Dialects and Runtimes

Here are several dialects and runtimes that you will likely encounter sooner or
later:

* [TypeScript](https://www.typescriptlang.org/index.html)
* [Node](https://nodejs.org/)
* [Deno](https://deno.land/)

I have mixed feelings about [**Deno**](https://deno.land/), and I still think
it's in an experimental phase as of this writing, yet feel free to play with it
too. [**Node**](https://nodejs.org/) is your choice if you want a battle-tested,
stable, and production-ready JavaScript runtime.

> **Want More Node? Keep on Reading**  
> I'll provide resources related to learning [**Node**](https://nodejs.org/),
> for the interested, in separate section near the end of this article.

## React, or Vue, or Angular, or Alpine, or... Oh my... 🤯

Especially when you are new to **JavaScript** and Front-End development you have
this dilemma: "_shall I learn React, or Vue, or Ember, or Alpine, or jQuery..._"

{{img(
  src="/images/size/w1200/2024/03/confused.jpeg",
  alt="Choosing a JavaScript framework can be confusing at times."
)}}

Well, there is a very simple solution to this:

Choose one framework, and stick with it until you master it.

> Your preferences drive your choices.
> 
> But when you have two equally appealing choices (popcorn or pringles; Angular
> or React, etc), your choices will create new neural pathways that
> literally will define your preferences.  

Learning a single JavaScript framework is often **good enough** because once you
learn one framework, it's not so difficult to translate the underlying concepts
to the next.

There are a lot of web frameworks out there, and when it comes to picking one to
study most of the time you'll find yourself choosing between 
[**React**](https://reactjs.org/) and [**Angular**](https://angular.io/).

Both [**React**](https://reactjs.org/) and [**Angular**](https://angular.io/)
are useful tools that solve similar problems that have robust open-source
ecosystems behind them. So, learning either one will suffice.

However, if I were you, I'd pick [**React**](https://reactjs.org/), and only
after I master [**React**](https://reactjs.org/), would I look at [**Angular
**](https://angular.io/).

I have several reasons for that:

* First and foremost, once you learn **React**, it's easier to learn the
  rest---The contrary is not always true.
* **React** treats **JavaScript** as a **first-class citizen**. That is not true
  for many other frameworks.
* **React** is (_often_) **not** opinionated, you can bend it to your will.
* **React** is **well-supported**, and [**well-documented**](https://reactjs.org/docs/getting-started.html).
* **React** is (_most of the time_) **fool-proof**. Unless you try hard to shoot
  yourself in the foot, you can always create a React application that will
  perform well.

> **Understanding Client-Side JavaScript Frameworks**  
> If you want to drill down
> deeper, [MDN has a curated list of learning resources](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks)
> on various client-side libraries and frameworks.

## Do I Really Need a JavaScript Framework Anyway?

Each framework comes with a **performance baggage**. Although it is very fast,
**React** is no exception: [**Virtual DOM**](https://reactjs.org/docs/faq-internals.html) 
is fantastic; however, it is not free. The same is true for all the abstraction layers that [**React
**](https://reactjs.org/) provides over native 
[DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)
and [Document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)
usage.

In **very** rare edge cases, you might find yourself opting out from using *
*React** and **Virtual DOM** and managing your apps' performance yourself by
using your own caching and DOM-manipulation strategies at a lower level
by [using the **DOM** API](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model), 
[Document fragments](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)
and all sorts of other clever tricks and black magic. I've been there; trust me,
**it's not as easy as it looks**.

Using a framework eases that burden off of your shoulders, with a _slight_ 
(_often negligible_) performance cost. That said, especially when you are
developing a hybrid application to some low-end mobile devices, using a
framework might not be your best option: You might be better off writing a
well-optimized plain **JavaScript** from scratch instead. Yet, these are more
exceptions than the norm: 99% or the time [**React**](https://reactjs.org/) 
(_or any other front-end framework for that matter_) will be **good enough** 
for your needs.

> **Why not Both?**  
> 
> You don't have to take an all-or-nothing approach:  
> With APIs
> like [`dangerouslySetInnerHTML()`](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml),
**React**, for example, can yield total control to your custom
> framework-agnostic **JavaScript**, and let you optimize parts of the app using
> plain **JavaScript** and [**DOM**](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) as
> you see fit.

## Your Hard Work Will Pay Off

When you consume all the content that I've shared so far, learning **_any_**
JavaScript framework will take a matter of **days** instead of weeks or months.

You'll be able to see the similarities and differences between various
frameworks, understand them at the core architecture level. You will better
understand which framework is a better fit for what kinds of problems.

Trust me, it's totally worth the opportunity cost of your time.

## The Source of Truth

The [ECMA-262 specification](https://tc39.es/ecma262/) contains the most
in-depth, detailed, and formalized information about **JavaScript**. It defines
the language. But being that formalized, it's difficult to understand at first.
So if you need the most trustworthy source of information about the language
details, the specification is the right place. But it's not for everyday use.

A new specification version is released every year. In-between these releases,
the latest specification draft is
at [https://tc39.es/ecma262](https://tc39.es/ecma262).

To read about new bleeding-edge features, including those that are "almost
standard" (Stage 3), see proposals
at [https://github.com/tc39/proposals](https://github.com/tc39/proposals).

I'll give an unconventional recommendation again: After you trust yourself that
you've learned enough JavaScript to be dangerous at
least. [read the JavaScript Language 
Specification **cover to cover**](https://tc39.github.io/ecma262/).

I'll be honest with you: [The **JavaScript** Language 
Specification](https://tc39.github.io/ecma262/) is much harder to
read than, say, the [**Go** Language Specification](https://golang.org/ref/spec). 
Honestly, it's much duller to read than the **Go** Language Specification; 
however, you will learn **a lot** by reading it.

### Blogs

* [scotch.io](https://scotch.io/)
* [David Walsh on JavaScript](https://davidwalsh.name/tutorials/javascript)

### Free JavaScript Courses

* [Coursera **JavaScript** Courses](https://www.coursera.org/search?query=javascript)
* [Channel9: **JavaScript**](https://channel9.msdn.com/Series/JavaScript-Fundamentals-Development-for-Absolute-Beginners)
* [Udacity: Introduction to **JavaScript**](https://www.udacity.com/course/intro-to-javascript--ud803)
* [Codecademy: Introduction to **JavaScript**](https://www.codecademy.com/learn/introduction-to-javascript)
* [TreeHouse: **JavaScript** Basics](https://teamtreehouse.com/library/javascript-basics)

### YouTube

* [The Weird History of **JavaScript**](https://www.youtube.com/watch?v=Sh6lK57Cuk4&list=PL0vfts4VzfNixzfaQWwDUg3W5TRbE7CyI)
* [**JavaScript** Crash Course](https://www.youtube.com/watch?v=hdI2bqOjy3c)
* [Introduction to **JavaScript**](https://www.youtube.com/playlist?list=PLZlA0Gpn_vH9k5ju1yq9qCDqvtuTVgTr6)
* [**JavaScript** Fundamentals](https://www.youtube.com/playlist?list=PLoYCgNOIyGACTDHuZtn0qoBdpzV9c327V)
* [**JavaScript** Form Validation](https://www.youtube.com/playlist?list=PLgBH1CvjOA636I8hnHSyuOnX341XQrBth)
* [Flavio: **JavaScript** Fundamentals](https://www.youtube.com/playlist?list=PLRpq_iSq4KCHV2hNst8Uu1cI-abPCXDyv)
* [**JavaScript** Game Walkthroughs](https://www.youtube.com/playlist?list=PLRD1Niz0lz1uR4W3ms6DygWMjXW-6hDB_)
* [Getting Started With **JavaScript**](https://www.youtube.com/watch?v=2nZiB1JItbY&list=PLDyQo7g0_nsX8_gZAB8KD1lL4j4halQBJ)
* [Modern JavaScript Tutorial](https://www.youtube.com/watch?v=iWOYAxlnaww&list=PL4cUxeGkcC9haFPT7J25Q9GRB_ZkFrQAc)
* [**JavaScript** in Three Hours](https://www.youtube.com/watch?v=PkZNo7MFNFg)

## Know Your Web Fundamentals

You cannot separate the web, browsers, CSS from JavaScript. So once you get
comfortable with programming in JavaScript, you'll inevitably need to dig into
web fundamentals. Here is a list of learning resources to get you started with
in that area.

### Web Fundamentals In General

* [Interneting Is Hard](https://www.internetingishard.com/)
* [MDN: Front-End Developer Learning Path](https://developer.mozilla.org/en-US/docs/Learn/Front-end_web_developer)
* [MDN: Web Technology for Developers](https://developer.mozilla.org/en-US/docs/Web)
* [GDN: Web Fundamentals](https://developers.google.com/web/)

### Learn Your HTML Like a Pro

* [HTML Spec](https://html.spec.whatwg.org/)
* [MDN: HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)
* [HyperText Markup Language](https://developer.mozilla.org/en-US/docs/Web/HTML)

### Become a CSS Master

* [MDN: Learn CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
* [Learn to Code HTML and CSS](https://learn.shayhowe.com/html-css/)
* [Learn to Style HTML Using CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
* [Box Model](https://hicksdesign.co.uk/boxmodel/)
* [CSS Specificity: Things You Should Know](https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/)
* [A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)
* [Learn CSS Grid](https://learncssgrid.com/)
* [Using CSS Animations](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)
* [Using CSS Transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)
* [CSS Guidelines](https://cssguidelin.es/)
* [CSS Tricks](https://css-tricks.com/)

### CSS Frameworks, Tools, and Paradigms

* [Scalable and Modern Architecture for CSS](https://smacss.com/) (*an oldie,
  but still the best conceptual framework*)
* [Sass: Syntactically Awesome Stylesheets](https://sass-lang.com/)
* [Styled Components](https://www.styled-components.com/)
* [BEM](http://getbem.com/)
* [Tailwind CSS](https://tailwindcss.com/)
* [Atomic CSS](https://acss.io/)

### Get Better at Visualization

Again, sooner or later you'll need to **visualize** things. That can be a  
simple dashboard, or a real-time histogram, or a time series data
visualization.  
Knowing of a couple of visualization libraries will be helpful.

Here are a few libraries that you can take a stab at:

* [d3](https://d3js.org/)
* [snapsvg](http://snapsvg.io/)
* [Raphaël](http://dmitrybaranovskiy.github.io/raphael/)

## Get Comfortable with Developer Tools

When it comes to web development, browser tooling is something that you
definitely need to get yourself familiar with. Here are a few pointers that can
help you in that area:

* [MDN: Understanding Client-Side Tools](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools)
* [Chrome Developer Tools](https://developers.google.com/web/tools/chrome-devtools/)
* [Firefox Developer Tools](https://developer.mozilla.org/en-US/docs/Tools)
* [Developer Tools Secrets that Shouldn't Be Secrets](https://christianheilmann.com/2021/11/01/developer-tools-secrets-that-shouldnt-be-secrets/)

Knowing your tools will help a **great deal** when you need to debug web user
interfaces and code.

## Know Your Bundlers

Related to developer tooling is bundlers and builders. The most popular ones
are [**Webpack**](https://webpack.js.org/), [**parcel**](https://parceljs.org/), 
[**rollup**](https://rollupjs.org/guide/en), and [**gulp**](https://gulpjs.com/).

If you are not sure where to start, I'd suggest you master [**Webpack**](https://webpack.js.org/) 
first, and take a stab at other tools later. But, regardless, all of these tools 
serve more-or-less similar purposes (_with some variations in how you configure 
them_); so once you know how one of them work conceptually, the others will 
just make sense.

## Browsers And Performance Optimization

This section is the last section, and there's a reason for that. Performance
optimization is so tempting that once you get the poison, you'll want to
optimize everything all the time.

![Premature optimization is the root of all evil.](/images/2021/11/premature.jpeg)

There's an old (_and quite correct_) saying about performance optimization:

> "The first rule of program optimization: Don't do it. The second rule of
> program optimization (_for experts only!_): Don't do it **yet**.

There's no need to prematurely **optimize** your code until you feel enough *
*pain** to justify the cause.
Remember, [everything is fast for small n](https://blog.codinghorror.com/everything-is-fast-for-small-n/).

If you don't take my word for it, maybe you can listen
to [Donald Knuth](https://en.wikipedia.org/wiki/Donald_Knuth):

> "Programmers waste enormous amounts of time thinking about, or worrying about,
> the speed of noncritical parts of their programs, and these attempts at
> efficiency actually have a strong negative impact when debugging and maintenance
> are considered. We should forget about small efficiencies, say about 97% of the
> time: **premature optimization is the root of all evil**. Yet we should not pass
> up our opportunities in that critical 3%."

One quick tip before giving performance pointers: **Write code for humans to
read**. When you need to choose between performance and readability, **always
choose readability**.

To quote it differently...

> "Always code as if the guy who ends up maintaining your code will be a  
> violent psychopath who knows where you live."  
> --- [**John Woods**, Software Engineer, Google](https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ)

Those said, here are a few pointers to guide you through the dark alleys of 
**JavaScript** performance optimization:

* [High-Performance JavaScript](https://www.goodreads.com/book/show/7008656.High_Performance_JavaScript)
* [Jank Free](http://jankfree.org/)
* [Jank Busters: Building Performant Web Apps](https://www.youtube.com/watch?v=hAzhayTnhEI)
* [Time to First Byte](https://web.dev/time-to-first-byte/)
* [First Meaningful Paint](https://web.dev/first-meaningful-paint/)
* [Extract Critical CSS](https://web.dev/extract-critical-css/)
* [Rendering Performance Case Studies](https://speakerdeck.com/addyosmani/velocityconf-rendering-performance-case-studies)
* [How not to Trigger a Layout in Webkit (_historical_)](http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html)
* [How to Write Fast, Memory-Efficient JavaScript (_historical_)](https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/)
* [Profiling Node.js](https://nodejs.org/en/blog/uncategorized/profiling-node-js/)
* [Debugging and Profiling Node.js](https://stackoverflow.com/questions/1911015/how-do-i-debug-node-js-applications/16512303#16512303)
* [v8 CPU and Memory Profiling](https://www.jetbrains.com/help/webstorm/v8-cpu-and-memory-profiling.html)
* [Top Node.js Metrics to Watch](https://www.oreilly.com/ideas/top-nodejs-metrics-to-watch)
* [Performance Testing Guidance for Web Applications](https://www.goodreads.com/book/show/3133219-performance-testing-guidance-for-web-applications)
* [The Art of Application Performance Testing: Help for Programmers and QA](https://www.goodreads.com/book/show/4843320-the-art-of-application-performance-testing)
* [How Do You Load Test a Web Application](https://www.goodreads.com/book/show/4843320-the-art-of-application-performance-testing)
* [Application Performance Testing Tutorial](https://www.goodreads.com/book/show/4843320-the-art-of-application-performance-testing)
* [Software Performance Testing](https://www.goodreads.com/book/show/4843320-the-art-of-application-performance-testing)
* [YouTube: Google Chrome Developers Channel](https://www.youtube.com/channel/UCnUYZLuoy1rq1aVMwx4aTzw)

While learning **JavaScript**, you'll inevitably have to learn browser internals 
to a certain extent. I believe this topic deserves a separate article on its own.
Yet, here are some resources to get you started if you want to dive into the
performance optimization rabbit hole:

* [JavaScript Engine Fundamentals](https://mathiasbynens.be/notes/shapes-ics)
* [How Browsers Work: Behind the Scenes of Modern Web Browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
* [v8 wiki](https://github.com/v8/v8/wiki)
* [High-Performance Browser Networking](https://hpbn.co/)
* [How to Write Fast, Memory Efficient **JavaScript**](https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/)
* [Learning v8](https://github.com/danbev/learning-v8)
* [v8 internals: an Illustrative Primer](https://codeburst.io/node-js-v8-internals-an-illustrative-primer-83766e983bf6)
* [Hidden Classes and Inline Caching in v8](https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html)
* [Optimization Tricks in v8](https://blog.ghaiklor.com/optimizations-tricks-in-v8-d284b6c8b183)
* [Performance tips for JavaScript in v8](https://www.html5rocks.com/en/tutorials/speed/v8/)
* [A Tour of v8 Compiler](http://www.jayconrod.com/posts/51/a-tour-of-v8-full-compiler)
* [How the v8 Engine Works](https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/)

## Conclusion

The videos, books, links, and resources I shared here are by no means
conclusive. **JavaScript** in particular, and **Front-End Development** in
general, are vast and ever-growing fields. Again, I believe the material you
find here will be a good starting point for newcomers and refreshers for the
masters alike.

Until next time... May the source be with you 🦄.

--------

## Section Contents

{{ roadmap_nav(selected=8) }}
