+++
#   (`-')           (`-').->
#   ( OO).->        (OO )__
# ,(_/----. .----. ,--. ,'-' doubt everything,
# |__,    |\_,-.  ||  | |  |
#  (_/   /    .' .'|  `-'  | be curious,
#  .'  .'_  .'  /_ |  .-.  |
# |       ||      ||  | |  | learn.
# `-------'`------'`--' `--'

title = "Be the Next Version of Yourself"
date = "2024-05-21"

[taxonomies]
tags = ["roadmap", "guide", "learning", "career"]
+++

![Be the Next Version of Yourself](/images/size/w1200/2024/03/journey.png)

## About This Article

> **This is a Living Document**  
> What you are reading is a **living document**.  
> I'll update this article whenever I get a similar question that has not
> entirely been addressed by what I have here.

I tried to keep the suggestions here as much field-agnostic as I can to make it
beneficial to you no matter what part of "_the stack_" you are interested in.

> **What Stack?!**  
> I also honestly believe that there is no such thing called "the stack", and
> the boundaries between the layers of "the stack" have vanished long time ago, so
> it is a "**mesh**"---_if anything---_rather than a stack, but that's the topic
> of another article 🙂.

## How To Read This Article

Do not just scan this article as if you are scanning through your birdsite news
feed. I am not going to be humble here: This article it is the accumulation of
years and years of experience. So, give it the **time** and **concentration** it
deserves.

While you are reading, you'll
find [links to other useful materials, such as this 
one](https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html).
**Do not skip them**: They are as important as the article itself.

With that said, let us begin, shall we?

## Introduction

People continuously ask me variations of the following questions at least a
couple of times a week:

_"I am a self-educated-developer/programming-enthusiast/you-name-it.  
I can write code; however, when I dive into complex codebases, I get lost."_

Or, something like that:

_"People assume that I know JavaScript, and I confess: I am a JavaScript
developer who doesn't know how to develop."_

I even got this one 😄:

_"Help me Obi-Wan Kenobi; you're my only hope."_

Since answering the same question over and over again is not the best use of
the [opportunity cost of my time](https://en.wikipedia.org/wiki/Opportunity_cost),
I wanted to answer them here, once and for all.

## Is It the "Impostor's Syndrome"?

Although there's a hint
of [impostor's syndrome](https://www.fastcompany.com/40421352/the-five-types-of-impostor-syndrome-and-how-to-beat-them)
in those questions, there also exists a **deep concern** that waits to be
addressed.

All of these questions translate to the following:

* "_How do I leap to the next level in my field of expertise?_"
* "_How do I become the next possible version of myself?_"

These questions require a much well-thought-out answer than a _"It's easy; you
see: Learn React and MongoDB, and you are good to go."_ answer.

So here it goes.

## Ask Questions, Doubt Everything, Trust in Evidence

If you forget everything else you read here, take this "_red pill_", and you'll
be fine:

> **Ask** Questions. **Doubt** everything. **Trust** in evidence.

☝️ That is the **ultimate** way to become a great developer: The rest is just
trivia.

Let me give you a related formula:

* Ask questions.
* Take initiative.
* Move out of your comfort zone.

Here is how it goes:

### Ask Questions

As long as there are people around and you know that there are things that you
don't know: Ask them out.

> There are naïve questions, tedious questions, ill-phrased questions, questions
> put after inadequate self-criticism. However, every question is a cry to
> understand the world. There is no such thing as a dumb question.
>
> **Carl Sagan
**---[The Demon-Haunted World: Science as a Candle in the Dark](https://www.goodreads.com/book/show/17349.The_Demon_Haunted_World)

* Ask dumb questions.
* Ask scary questions.
* The more you ask, the better.

While you are at
it, [learn how to ask smart questions](http://www.catb.org/esr/faqs/smart-questions.html)
and digest the fact
that [there are no dumb questions](https://www.goodreads.com/book/show/17349.The_Demon_Haunted_World).

### Take Initiative

After asking as many questions as you **possibly** can, it is time to take the
reins into your hand because after asking enough questions, you'll eventually
run into a set of problems that your coworkers, your friends, and your
colleagues don't know how to solve either.

Trust me; this is **very** easy 😉.

What you'll do next is even easier:

* **Decide** that you will figure out and solve this unsolvable problem anyway.
* Then solve it.

Voila!

You have solved a domain-specific problem that nobody else has an answer to.

### Move Out of Your Comfort Zone

The more you program, the more issues you'll find that...

* You don't know.
* Your colleagues don't know.
* Google doesn't know.
* And you'll **have to** figure out (_as if your job depends on it---'cuz it
  does 😉_).

Try to challenge yourself to 
[**move out of your comfort zone**](https://www.lifehack.org/articles/communication/this-what-happens-when-you-move-out-your-comfort-zone.html).

Screw everything. Get your pieces together. 
[**Focus**](https://www.heysigmund.com/why-what-you-focus-on-is-what-becomes-powerful-why-your-thoughts-and-feelings-matter/)
and solve that problem.

Rinse and repeat this process, and you'll be a domain expert in no time 🤓!

I'm not kidding. And it's not **that** hard.

### Share Your Knowledge with the Community

Share your knowledge: Help others.

**Software engineering is not a path that you walk alone**. Learning to share
your knowledge with the community is as important (_if not more_) than learning
something new.

There's a vast community of developers who are willing to help each other: Be
one of them.

Don't shy away: You don't have to be a guru to share your knowledge. Opening
yourself up, sharing your experience, asking others' opinions takes you a long
way.

## You Are not Your Code

"_You_" and "_your code_" are 
[**orthogonal**](https://en.wikipedia.org/wiki/Orthogonality) to each other.

There is no shame in sharing your code.

Share every semicolon you type on your IDE in 
[**GitHub**](https://github.com/) (_or a similar open source code repository of your
choice_).

* Whenever you discover something new: **share it**.
* Whenever you have a problem: **yelp for help**.
* Whenever you write code: [**put it to GitHub**](https://github.com/) or 
  [**create a Gist**](https://gist.github.com/).

## Code Is Nothing

Don't be afraid to put the code you write out in the open.

Don't be ashamed of your code.

You know what? **Code is nothing**.

Trust me; it took a hell lot of years to digest that fact. And it is true:  
**Code is nothing**.

* What you create with your code is everything.
* The way you **share** your knowledge is everything.
* The **value** you add to the **community** is everything.

> All great fighting is the same, Eragon, even as all great warriors are the
> same. Past a certain point, **it does not matter** whether you wield a sword, a
> claw, a tooth, or a tail. It's true, you must be capable with your weapon, but
> anyone with the time and inclination can acquire technical proficiency.
>
> To achieve greatness though, that requires **artistry**. That requires 
> **imagination** and **thoughtfulness**, and it's those qualities that the best
> warriors share, even if, on the surface, they appear entirely different.
>
> **Christopher Paolini**---[The Inheritance Cycle](https://www.goodreads.com/book/show/7664041-inheritance)

Code, in itself, is **nothing**. It is just a _tool_.

Code is just a tool: Sharing your code, and asking other's feedback about your
code will improve you **a lot** as a developer.

With that kept in mind, here are a few developer communities that you might want
to join and share your code.

* [Stack Exchange](https://stackexchange.com/sites)
* [Mozilla Developer Network (_MDN_)](https://developer.mozilla.org/en-US/)
* [FEDs on Slack](http://fedsonslack.com/)
* [Reddit/Programming](https://www.reddit.com/r/programming)
* [dev.to](https://dev.to/)
* [Hashnode](https://hashnode.com/explore)

> **This List is Just a Starting Point**  
> The list of communities I shared here is, by no means, a definitive or
> conclusive list: A google search around your favorite programming language, or
> your favorite framework, or your favorite toolchain will reveal at least a dozen
> of quality developer groups that you can join in a heart beat.

### Stack Exchange

[Stack Exchange](https://stackexchange.com/sites) is an absolute must as a
programmer community site for anyone who is serious about **development** and *
*programming**.

Don't just read it. Be a part of it. Participate in its discussions. **Add value
to it**.

### Mozilla Developer Network

If you're at all interested in the modern web and the technology stack around
it [Mozilla Developer Network (_MDN_)](https://developer.mozilla.org/en-US/) is
the community to join.

**MDN** also provides a ton of information about all of Mozilla's products and
how to use them properly.

### FEDs on Slack

No, they are not the feds that you are thinking about 🙂.

[FEDS on Slack](http://fedsonslack.com/) is a helpful community for top-notch
front-end developers.

[Join there](http://fedsonslack.com/), and actively contribute to the
discussions.

### Reddit

There are also some subreddits such
as [`/r/programming`](https://www.reddit.com/r/programming)
and [`/r/learnprogramming`](https://www.reddit.com/r/learnprogramming) that you
might want to follow.

Though reddit is its own universe, don't get lost in it 😉.

### dev.to

This one is so obvious; it almost hurts that there are people who don't know it:

[**dev.to** is a **capable**, **friendly**, and **vibrant** 
community of coders](https://dev.to/).

If you haven't joined yet, what are you waiting for?

### Hashnode

[Hashnode](https://hashnode.com/explore) is the easiest way to start a developer
blog on your personal domain for free and **connect** with the readers through
our global dev community. Like, dev.to, this community is pretty vibrant and
helpful too.Read the Source, Luke

* **Copy** what others have done before you.
* [Read and **understand** the source code 
  piece by piece](https://blog.codinghorror.com/learn-to-read-the-source-luke/).
* And then, and only then, **replicate** it your own way.

If you are planning to become a developer, you are going to be really **intimate
** with **the source**. And that's coming up next.

## Read the Source, Luke

![Read the source, Luke.](/images/2021/10/read-the-source.jpeg)

Related to _sharing your code openly_:

**Indulge in open source** and **read** as much code as you can.

> **Explore Without Fear**  
> Make "_looking 'under the hood' of the open source project you like_" a habit.

**Do. Or do not. There's no try**.

Initially, reading other's code will feel painful, daunting, even. You'll feel
yourself like an alien in somebody else's backyard. It's difficult to think from
someone else's point of view, observe how they approach the task at hand,
analyze **how** they solve a particular problem, and more importantly **why**
they chose that particular approach instead of a different one.

Reading others' code takes time, dedication, and practice: And blimey---it's a
time well spent.

> **Reading Others' Code**  
> Reading others' code is just like reading finance: It will feel weird. At
> first, it'll feel difficult. And the more you do it, the more comfortable you'll
> get at it.

The more you read, the better you'll get the hang of the **logical constructs**,
the **terminology**, the **concepts**, and the overall **program flow**.

In addition to all these, reading open source code **teaches** you how to
write [by using the conventions and idioms of the language](http://wiki.c2.com/?CodingConvention=).

## Add Value to The Community

As a follow-up to the above "_Share Your Knowledge with the Community_
guideline, **the more you add value to the community, the more value you receive
**.

The least you can do to add value is to [contribute to the 
**open source** community](https://opensource.guide/how-to-contribute/).

By adding value to the **open source** community you'll...

* **Improve** your existing skills.
* **Find** mentors to help you.
* **Be** a mentor and help others.
* **Build** public artifacts that help you gain visibility.
* Better visibility often means better **career** opportunities too.
* You'll get better at **people skills**.

More importantly, You'll feel **empowered 💪**:

You'll gain self-confidence, which will help beat the inner impostor out of
you (_more on that later_).

## Being a **Full StackOverflow Developer** is Okay

Don't be afraid to search: Even the most experienced developers search the most
uncomplicated things all the time, that's not a shame.

Here's a recent tweet that I shared on the topic:

> Hey, I work at Cisco (which is a networking-focused company) and every time I
> need to NAT/split a subnet/cluster etc I google "IP Subnet Calculator".
>
> Googling is not a shame:  
> STFW instead of memorizing stuff, use your brain for more important things:
> like solving problems.
>
> --- Volkan Özçelik 🦄 (*September 3, 2018*)

Don't believe me? Then listen to the other experts who feel the same:

> Hi, I am Chris. I coded 17 years JavaScript and wrote books and articles.
> Without looking things up
> and [@code](https://twitter.com/code?ref_src=twsrc%5Etfw)
> autocomplete, It'd be lost.
>
> --- Chris Heilmann (@codepo8) [February 26, 2017](https://twitter.com/codepo8/status/835986409890672640?ref_src=twsrc%5Etfw)

> Hi, I'm Michael. I've been writing JavaScript since 2001 and I still have to
> look up how to remove whitespace from a
> string. [https://t.co/obYoCzKe3b](https://t.co/obYoCzKe3b)
>
> --- Michael Bleigh (@mbleigh) [February 26, 2017](https://twitter.com/mbleigh/status/835942125992759296?ref_src=twsrc%5Etfw)

> Hello, I'm Malte. In 6 years at Google I had to code 3 advanced algorithms.
> Looked them up on Wikipedia. [https://t.co/BTH3I4TpTO](https://t.co/BTH3I4TpTO)
>
> --- Malte Ubl (@cramforce) [February 26, 2017](https://twitter.com/cramforce/status/835976913160056833?ref_src=twsrc%5Etfw)

> Hi I'm Dan, and I work on Polymer. The other day, I had to read the docs for
> how to use Polymer's data
> binding. [https://t.co/MarTrxsiKL](https://t.co/MarTrxsiKL)
>
> --- Dan Freedman (@danfreedman) [February 26, 2017](https://twitter.com/danfreedman/status/835978986505166849?ref_src=twsrc%5Etfw)

> Hi, my name is Sean. I maintain ORMs for a living but have to google the
> CREATE TABLE syntax every time I do it in
> SQL. [https://t.co/TP8A2IKjjx](https://t.co/TP8A2IKjjx)
>
> --- Spooky Sage Griffin 🏳️‍⚧️🏳️‍🌈 (@sgrif) [February 26, 2017](https://twitter.com/sgrif/status/835929896794882048?ref_src=twsrc%5Etfw)

> Hi, my name is Sarah. I've been writing Rails code since 2006, and I still
> get \`has\_one\` and \`belongs\_to\`
> confused. [https://t.co/NFA4uEmiSz](https://t.co/NFA4uEmiSz)
>
> --- Sarah Mei (@sarahmei) [February 26, 2017](https://twitter.com/sarahmei/status/835927143833985024?ref_src=twsrc%5Etfw)

> Hi, my name is Harper. I have programmed computers since the 90s and still
> have google to split a string. Or the correct args for
> ln. [https://t.co/zV7WxrqHc8](https://t.co/zV7WxrqHc8)
>
> --- harper 🤯 (@harper) [February 26, 2017](https://twitter.com/harper/status/835979694264680448?ref_src=twsrc%5Etfw)

> Hi. My name is Erin. I've been writing JavaScript for 16 years and I still
> have to look up the function signature for
> Array.splice. [https://t.co/OaxYz1K7Xx](https://t.co/OaxYz1K7Xx)
>
> --- she builds their fires (@ErinIshimoticha) [February 26, 2017](https://twitter.com/ErinIshimoticha/status/835981374309941249?ref_src=twsrc%5Etfw)

Looking things up is **not** a shame.

## To Learn, "_Learn to Learn_" First

With one **caveat** though: Do not apply the knowledge you acquired without
learning about the details.

Don't just copy and paste things. Learn the "**why**"s and "**how**"s of the
knowledge before using it in your code.

Don't just memorize, "**learn to learn**" instead.

You'll see more about "_learning to learn_" down below: Just 🐻 with me.

## Know How Your Wetware 🧠 Works

Your "_wetware_" is not good at memorizing: So, don't memorize those software
design patterns, or those interview questions and algorithmic puzzles.

> **Don't Memorize What You Can Look Up**  
> There is no reason to memorize anything as long as you can look it up.

On the other hand, [your **wetware** is a Yoda-level-master at **pattern
recognition**](https://www.sciencedirect.com/science/article/pii/S0020737369800246).

**Expose** your wetware to as many patterns and variations as you can, and let
your subconscious do the rest of the job.

That's why one of the best ways to learn something is to **copy** what others
have done before you:

> **Imitation Is Learning**  
> Imitate people you admire to be, to be like them.

## You Learn by Imitation

[You learn by imitation](https://www.jstor.org/stable/2762020): Learning
software is no exception to that.

Learning how to name variables, or how to create a folder structure, or how to
couple different modules of your code together, how to document your code... is
much easier when you **imitate** how others have done the same thing before you.

> **Stand on the Shoulders of the Giants**  
> Learn from the cumulative experience of developers before you.

Even if you want to reinvent the wheel first look at what others have done
already, before doing it your way.

> **About that Wheel...** 
> 
> [The "wheel" is, ironically, the most re-invented tool so far](@/roadmap/chisel.md)
> 🙂.

Since the day we are born, we learn by imitating. Our brains are wired to *
*recognize patterns**, **copy**, **mimic**, **imitate**, and **mirror**.

The same applies when learning how to code, too:

* **Read** others' code.
* **Copy** and **replicate** what you see.

In time, you'll understand how different patterns tie together:

You'll see the "_why_"s behind those "_what_"s.

And the way to reach there is to...

* First, **imitate** others,
* Then understand **how** the thing you imitated works,
* And only then start questioning **why** that code is implemented that way,
* And, finally, think about how to write it **differently**,
* Then, think about **if** writing it differently solves your problem more
  elegantly.

## Take Your Time

Learning by imitation is a slow and gradual process: It requires a lot of time
and patience. I'm sorry and there are no shortcuts to speed it up. Though, as in
anything, practice makes perfect.

The more you read others' code, the better you'll get at it: It's worth the time
and energy you invest in.

> **Hint** 
> 
> For starters, you might want to start reading the source code of the open
> source frameworks that you love: The transition will feel much easier then.

After you get used to the codebase, it'll start to feel familiar, and then can
you find a chance to dig in further.

When you feel you are familiar enough with the codebase,
[**fork**](https://help.github.com/en/github/getting-started-with-github/fork-a-repo)
the project on your development environment, then **build** it, and then **debug
** it to **understand** how its different pieces of the code interact with each
other.

Do this exercise regularly, **every single day**, and one day you'll wake up and
utter:

"_I know kung-fu._"

## Don't Hang onto a Single Paradigm

Whatever you do, don't stick to a single language, or a single paradigm.

**Embrace change**, embrace different languages, embrace different approaches.

> **Don't Have Firm Opinions on Anything**
> 
> There is no single correct solution to any problem. Most of the time, there is
> more than a single truth. More often than not, those **truths coexist**.
>
> Truth coexists.
>
> Consider this before
> talking/typing. 
>
> --- Volkan Özçelik 🦄 (*October 6, 2021*)

The more languages you know, the broader spectrum of paradigms you'll be exposed
to. Knowing more than one language will help you shape the way you think. You'll
approach problems **differently**. And that is **good**.

When you expand your horizon, and when you get out of your comfort zone, you
will be able to combine seemingly unrelated facts with each other to come up
with a solution---That is the _very_ definition of **creativity**.

With enough accumulated **creativity** and **artistry**, you will _eventually_
be the one to find a solution to "_that_" problem even Google has no answer to.

## There Are No Shortcuts

Related, somewhat ironically, to the above quote, we are not in the Matrix.

Anything that claims you to "_teach X language in Y weeks_" is a big honking
lie.

Take it easy.

Learn gradually.

Give the time your brain deserves to internalize what you have learned.

Learning requires:

* **Repetition**
* Routines
* [Habitualization](https://blogsociology.wordpress.com/tag/habitualization/) \*
* Dedication
* A hell lot of perspiration
* And **repetition**

> \* "[Habitualization](https://blogsociology.wordpress.com/tag/habitualization/)"
> is just a big fancy word for creating habits based on stimulation in your
> environment.

Moreover, once you dedicate yourself, you'll be amazed at the progress you make.

The only difference between you and the role model that you want to be will be
the amount of time you **regularly** dedicate yourself to your kung-fu and the
number of things you **sacrifice** on the way.

Learning is a means: It's **not** the end.

> **Surprise: Learning Never Ends**  
> If you are in this industry, you will continuously learn **forever**, be ready
> for that.

## Beat the $#!% Out of the Impostor in You

From time to time, you may feel that you are lagging behind, or you don't know
as much as your colleagues---That is a well-documented psychological phenomenon
called [the impostor's syndrome](https://www.fastcompany.com/40421352/the-five-types-of-impostor-syndrome-and-how-to-beat-them).

You might get a feeling that you are just lucky to be in your place. You might
feel that you don't deserve your place.

You know what? That's complete and utter 🐴 💩.

Here's why:

* **Nobody** knows everything.
* **Nobody** is perfect.
* **Everyone** has a unique set of skills.

You are **priceless** in what you bring to your environment, and nobody can add
the values you specifically add.

> **Important**  
> It is the **union** of the individual skills of the people that make the team
> more prominent than the sum of its contributors.

Most people experience moments of doubt, and that's normal. The important part
is not to let your uncertainty control your actions.

> **Yeet the Impostor Out of You**  
> Here's a stupid trick that works: If you tell yourself you'll never feel like
> an impostor, guess what? You'll never feel like an impostor.

Just accept the fact that not knowing everything is normal. You'll learn things
when you need to learn things---That's okay.

You don't have to learn that new API, or that new cool framework.

Also, even if you do have to, you don't have to learn all of it... like... right
now 😁---Cut yourself some slack. **Give yourself the time you deserve**.

If you are still not sure how to act like
that, [this article gives a couple of tips and 
tricks](https://www.fastcompany.com/40421352/the-five-types-of-impostor-syndrome-and-how-to-beat-them)
on how to beat the impostor in you.

After the fact that you are better than you think you are is set straight, we
can move on to the more technical parts of the equation.

## Be a Good Software Craftsman

To be a good software craftsman is to read what others have to say about it.

There is so much material about the subject that giving a digestible summary
here is practically impossible. So, I'll provide a list of **bedtime reading**
material instead.

I recommend you read the following the resources that I've listed here
in [Resources Every Developer Must Read---No Exceptions](https://www.zerotohero.dev/bedtime-reading/)
**cover to cover**, twice.

* **Once**: Before you begin your programming journey.
* **Next**: After you have been coding for several years, and you have learned
  more than one programming language well.

A heads up: It's a relatively long list, and it might take a while: Take your
time.

What's common
in [all of those resources](https://www.zerotohero.dev/bedtime-reading/) is that
they don't talk about how to use a specific programming language, they talk
about things that are bigger than code.

They are **essential**. I can go as far as advising you to read them **before**
you even start learning to code.

**Why?**

If you want to be a good software craftsman, **code** is of **secondary**
importance. "**_Code is nothing_**", remember?

**Don't give code more value than it deserves**.

## Know Your Tools Well

What tools you choose will depend on what you want to achieve. This section will
introduce a few common paths that you might want to explore. Though, don't take
is as an end-all be-all reference.

> **You Know Where You Want to Go Better**
> 
> You know where you want to go better than I do, and it's virtually impossible
> for me to cover every possible niche. Instead, the areas I list below will be
> mostly the ones that I'm interested in and regularly exploring. I'll add more
> resources here as I create more content.

For example, if you want to get better at **JavaScript** in particular and *
*Front-End Development** in
general, [Learn Your JavaScript the Unconventional Way](@/roadmap/learn-javascript-the-unconventional-way.md)
can be a great starting point. While at there, it would be good to remind
yourself
that [Knowing JavaScript Is Not Good Enough](@/roadmap/knowing-javascript-is-not-good-enough.md).
And for an unorthodox take on the subject matter, you might even want
to [Learn Haskell First to Learn JavaScript Better](@/roadmap/learn-haskell.md).

Or maybe you want to follow the path of an User Experience Designer. In that
case, on **Usability** and **User Experience**, I've gathered quite a few
resources
in [Don't Make the User Think](@/roadmap/ramp-up-in-user-experience-design.md)
that might pique your interest.

## How About Software Design Patterns?

A quick advice about studying **Software Design Patterns** is, don't try to fit
everything into a "_pattern_". Go with the flow.

Experimenting with design patterns the first time is like playing paintball the
first time: It'll be fun, but it sure will be **messy** and it will hurt a lot.

Design patterns are good, and you should read about them; however, keep in mind
that they are **guidelines**, don't take them as gospel.

![They are more guidelines than actual rules.](/images/2021/10/Screen-Shot-2021-10-14-at-2.14.30-PM.png)

Don't try to fit every problem you have into a pattern.

Yes, there are specific sets of problems that fit well with certain software
architecture patterns. One the other hand, forcing patterns into every single
problem set will be counterproductive, at the very least.

## How About Those "_Interview Prep_" Books and Code Banks?

For books like "_Cracking the Coding Interview_", and for websites like 
"_Leetcode_", well, I have mixed feelings.

If you want to pass an interview, sure thing, go ahead and read them.

If you are prepping for an interview, not studying those resources is *
*illogical**: If that's how the game is played, you should play it by the rules
unless you are confident that you can set your own rules.

> **About Competitive Programming Challenges**
>
> If you want to work for a company as a software developer, and if that company
> prefers asking competitive programming questions instead of seeking for a
> diversified and complementary mixture of creative human beings, then you have no
> other option but study those interview prep books and websites.
>
> From my anecdotal observation, that's how the majority of the Silly Cone
> Valley companies are right now. There are exceptions, but it's **very** rare.
> And from the looks of it, it's not about to change anytime soon.

Though, I have a sliver of hope that, if you have read this article thus far,
you have a strong belief that you are **meant to be** more than just a _walking
scientific calculator_ that can backtrack a maze, or reverse a binary tree 🙂.

For mastering of your craftsmanship, interview prep books and websites are **not
** worth your time.

I mean, **do** buy those interview prep books, and **do** solve the question in
those "_programming interview questions code bank_" websites; however, treat
them as "_side dishes_", not as the main course.

Don't let a stupid recursive array manipulation interview question dictate how
good a software craftsman you are.

## Flex Your Algorithmic Muscle

Though, don't get me wrong here. Learning algorithms; learning when, why, and
how to use them is **priceless**. Memorizing algorithms, on the other hand, to
pass a technical interview is a waste of time. This is a a subtle, yet
importance difference.

Don't learn **data structures** and **algorithms** for the sake of studying for
interviews. Learn them **because** it makes you a **better** programmer.

Regardless, studying [*competitive programming questions*](https://projecteuler.net/)
will help you in your programming interviews. There are even shortcuts (_like
websites like leetcode_) that help you practice your algorithmic chops.

Yet, that's not the point. **Do not take shortcuts**.

Spend time to **understand** a **broad spectrum** of data structures and
algorithms: Learn **when** to use them, **how** to use them, when **not** to use
them.

Learn what the **benefits** of a particular type of algorithm are.

Learn what the **liabilities** of using specific data structures are.

Here are two excellent (_and free_) resources to learn your algorithms:

* [Competitive Programmer's Handbook](https://cses.fi/book/index.html)
* [Teach Yourself CS](https://teachyourselfcs.com/)

Aside from them, I'd suggest reading these two books **cover-to-cover**, not
skipping anything. Genuinely ingest everything in them:

* [The Algorithm Design Manual---S. Skiena](https://www.goodreads.com/book/show/425208.The_Algorithm_Design_Manual)
* [Introduction to Algorithms---Cormen, et., al.](https://www.goodreads.com/book/show/108986.Introduction_to_Algorithms)

There are other books too, and you can investigate them on your own. Though,
these two books will cover all your algorithm bases.

## Learn to Learn

Before even beginning your learning adventure, you need to know two things:

* You should **know** how you learn: What type of learner you are.
* You need to "**learn to learn**".

That might sound "_too meta_", so let me elaborate:

**Learning to learn** is easier said than done because to "_learn to learn_",
you have to [**know yourself**](https://en.wikipedia.org/wiki/Know_thyself)
first---you have to have an idea of what type of a learner you are: There is
no "_one size fits all_" solution in learning.

> "Every fighter has a different way of eating yogurt."  
> --- Turkish proverb

Are you an [**inductive learner**](https://en.wikipedia.org/wiki/Inductive_reasoning) who starts with the
foundation and understands the bigger picture by connecting pieces together.

Alternatively, are you a [**deductive learner**](https://en.wikipedia.org/wiki/Deductive_reasoning) who likes to see a
working system as a whole, only to split it into is building blocks recursively,
and understand each piece until there is nothing left to split apart.

Are you a [**visual learner**](https://www.thestudygurus.com/visual-study-tips/)? Do you use flashcards? Do
you want to draw things on a whiteboard? Do you want to look at things "_from a
different perspective_" to "_get the hang of it_". Do you understand things best
when you have a "_clear picture_" in your mind?

## Learn How You Learn

Do you like watching videos to learn things, or are you more comfortable when
you read books and articles and then apply the concepts you read at your own
pace?

Do you learn by playing toy projects?

Do you learn by reading others' code?

There's no exact answer to the "_how do I learn?_" question.

If you're not sure, I'd suggest you try a variety of different approaches and
see which ones fit the best for you.

> **Caveat**  
> An unrelated cautionary note: Most people don't fit perfectly into a single
> learning-style category, so it's highly likely that you will be better off using
**a mixture of learning styles** and techniques.

Watch yourself, and be more aware of what styles of learning you prefer the
most.

## Don't Rush

Learning to code is no different from learning any other skill: It's a **slow**,
**painstaking**, and **gradual** process. The more you practice, the better
you'll get.

Take "_reading others' code_" for example. Do you have a problem reading others'
code? Then attack the problem right at its heart:

* **Pick** a few open source projects from [GitHub](https://github.com/).
* **Read** the code in there until your eyes bleed.
* Then **read some more**.

It is a slow and gradual process: **Be patient**.

## Before You Begin Programming...

No matter what you want to learn, if you aspire to be a good developer, you will
need the following skills. So I encourage you to learn them sooner than later.

After you are comfortable with them, you can continue your programming journey
from where you left off.

Here is a short list of skills that you'll likely need for starters:

* A basic-level of **terminal** knowledge.
* Ability to write simple **shell scripts**.
* Basic knowledge of **git** and **GitHub**.
* And knowledge about how to **ssh** into a server.

## Where to Go From Here

[There are a handful of articles that I keep on writing to augment 
this roadmap](/tags/roadmap).

Here are some of those that you might find interesting:

### On Innovation and Creativity

* [Grab Your Chisel and Start Pounding](https://www.zerotohero.dev/chisel/)
* [Who Else is Ready to Hack?](https://www.zerotohero.dev/hack-the-system/)
* [A Startup Founder's Bedtime Reading List](https://www.zerotohero.dev/a-startup-founders-bedtime-reading-list/)

### On Software Craftsmanship

* [Resources Every Developer Must Read---No Exceptions](https://www.zerotohero.dev/bedtime-reading/)
* [A Glossary of Mostly Developer-Related Things](https://www.zerotohero.dev/glossary/)
* [Paint Me Like One of Your French Design Patterns](https://www.zerotohero.dev/paint-me-like-one-of-your-french-design-patterns/)
* [You Need Testing](https://www.zerotohero.dev/you-need-testing/)
* [Security Is Not Optional](https://www.zerotohero.dev/security/)
* [Tame Your Regular Expressions](https://www.zerotohero.dev/regexp/)
* [One Does Not Simply "Terminal" 👌](https://www.zerotohero.dev/one-does-not-simply-terminal/)
* [Git Comfortable](https://www.zerotohero.dev/git/)
* [Master Your vim](https://www.zerotohero.dev/vim/)

### On JavaScript and Friends

* [Learn Your JavaScript the Unconventional Way](https://www.zerotohero.dev/learn-javascript-the-unconventional-way/)
* [Knowing JavaScript Is Not Good Enough](https://www.zerotohero.dev/knowing-javascript-is-not-good-enough/)
* [Want to Learn JavaScript? Learn Haskell First](https://www.zerotohero.dev/learn-haskell/)

### On Go Programming

* [Places to Learn Go](https://www.zerotohero.dev/learn-go/)

### On Design and Typography

* [Orange Is the New Purple](https://www.zerotohero.dev/color-theory/)
* [Get Better at Typography](https://www.zerotohero.dev/typography/)

### On User Experience and Usability

* [Don't Make the User Think](https://www.zerotohero.dev/ramp-up-in-user-experience-design/)

## Conclusion

If you have been patient enough to read to the end of this article without
skipping
anything, [you are better than 75% the world already](https://www.nngroup.com/articles/how-little-do-users-read/).
Congratulations.

Learning is a never-ending journey. And learning is also a way to **find
yourself**. Finding yourself---finding your core idenity---has never been an
easy task.

Of course there will be times you'll stumble upon. In those times, make sure you
are surrounded by a welcoming community to support you and push you forward.

I'll write a follow-up article, focusing on a more technical roadmap, especially
focusing on the path of becoming a developer.

Until next time... May the source be with you 🦄.

## Section Contents

{{ roadmap_nav(selected=1) }}
